{"layout":"post","title":"How to remove file documents from SOLR index after been replaced in nodes in Drupal 7","categories":["articles"],"tags":["SOLR",null,"Drupal"],"body":"<p>If you have revisions enabled in your content types, it keeps all your old files on the server (associated with old revisions), \nso replacing a file definitely is harder. </p>\n<p>Even though if you don’t have revisions enabled, if you try to remove it and add it again to the node, the name/link is \nupdated, but since a file with that name is kept on the server and there is a name duplication, Drupal adds those “_0”, \n“_1” etc suffixes to future uploaded versions of that file’s name.</p>\n<p>In term of node render is not a problem, but in terms of SOLR indexing all those files will be indexed, so instead of get \none record for a match is possible get N records where N is the number of time do you overwrite the same file.</p>\n<p>Then, to resolve this annoying behavior I will show you a solution to remove a file document from SOLR index if a file is \nremoved from a node. this solution use <a href=\"https://www.drupal.org/project/entity\">Entity API</a> module so it should be added \nas a dependency in your module .info file.</p>\n<pre><code>/**\n * Implements hook_node_update().\n */\nfunction MYMODULE_node_update($node) {\n\n  // Array of content types to act on.\n  if (in_array($node-&gt;type, array(&#39;article&#39;, &#39;blog_post&#39;))) {\n    $wrapper = entity_metadata_wrapper(&#39;node&#39;, $node);\n    $original_wrapper = entity_metadata_wrapper(&#39;node&#39;, $node-&gt;original);\n\n    // Array of file fields to act on.\n    foreach (array(&#39;field_public_files&#39;, &#39;field_private_files&#39;) as $field) {\n      if (!isset($original_wrapper-&gt;{$field})) {\n        continue;\n      }\n      $current_files = array();\n      $original_files = array();\n\n      // Get files that were attached to the original node (before update).\n      foreach ($original_wrapper-&gt;{$field}-&gt;value() as $file) {\n        $original_files[] = $file[&#39;fid&#39;];\n      }\n      // Stop if there were no files previously attached.\n      if (empty($original_files)) {\n        continue;\n      }\n\n      // Get files currently attached to the node (after update).\n      foreach ($wrapper-&gt;{$field}-&gt;value() as $file) {\n        $current_files[] = $file[&#39;fid&#39;];\n      }\n\n      // Delete files that were in the original node but were removed during this update\n      $deleted_files = array_diff($original_files, $current_files);\n      if(!empty($deleted_files)) {\n       $env_id = apachesolr_default_environment();\n       $solr = apachesolr_get_solr($env_id);\n       foreach ($deleted_files as $fid) {\n         $file_id = apachesolr_document_id($fid, &#39;file&#39;) . &#39;-&#39; . $node-&gt;nid;\n\n         // Remove file document from SOLR index, re-index is not required,\n         $solr-&gt;deleteByQuery(&quot;id:$file_id&quot;);\n       }\n      }\n    }\n      $deleted_files = array_diff($original_files, $current_files);\n      if(!empty($deleted_files)) {\n\n    }\n  }\n}\n</code></pre><p>The code above react when a node is updated for specific content types and specific fields, using function <a href=\"http://www.drupalcontrib.org/api/drupal/contributions!entity!entity.module/function/entity_metadata_wrapper/7\">entity_metadata_wrapper</a> \nwe can determine the information of our node before update and after update.</p>\n<p>After calculate if some files were deleted the logic to delete the file document from SOLR is applied, let me see that code \nin detail</p>\n<pre><code>$env_id = apachesolr_default_environment();\n$solr = apachesolr_get_solr($env_id);\nforeach ($deleted_files as $fid) {\n $file_id = apachesolr_document_id($fid, &#39;file&#39;) . &#39;-&#39; . $node-&gt;nid;\n\n // Remove file document from SOLR index, re-index is not required,\n $solr-&gt;deleteByQuery(&quot;id:$file_id&quot;);\n}\n</code></pre><p>Firstly, a SOLR object instance is declared. In my example I use the default SOLR instance, if you have more than one instance \nof SOLR is necessary to change the logic to use the proper instance.</p>\n<p>Using <a href=\"http://www.drupalcontrib.org/api/drupal/contributions!apachesolr!apachesolr.module/function/apachesolr_document_id/6\">apachesolr_document_id</a> function \nthe SOLR ID is calculated using the <strong>fid</strong>, <strong>file</strong> type and providing the specific relation to the specific node subject of \nupdate, because in some Drupal installs a file could be associated to several nodes.</p>\n<p>Finally, using <a href=\"http://www.drupalcontrib.org/api/drupal/contributions!search_api_solr!includes!solr_connection.interface.inc/function/SearchApiSolrConnectionInterface%3A%3AdeleteByQuery/7\">deleteByQuery</a> method the delete from SOLR index is requested, \nthis delete is applied immediately, SOLR re-index is not required.</p>\n<p>I expect you found this article useful.</p>\n","updatedAt":"2017-09-05T17:40:56.000Z"}
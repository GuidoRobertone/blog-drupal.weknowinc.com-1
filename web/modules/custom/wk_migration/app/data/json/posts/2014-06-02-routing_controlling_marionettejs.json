{"layout":"post","title":"Routing and Controlling with MarionetteJS","description":"Implementing Routing & Contrilling with MarionetteJS.","categories":["articles"],"tags":["Ajax","Javascript","RequireJS","MarionetteJS","BackboneJS","MarionetteJS"],"draft":false,"body":"<p><a target=\"_blank\" href=\"http://marionettejs.com/\">MarionetteJS</a>  is a layer that sits on <a target=\"_blank\" href=\"http://backbonejs.org\">BackboneJS</a> to create scalable and professional applications.</p>\n<p>Some features of MarionetteJS are :</p>\n<ul>\n<li>Scalable: applications are built in modules, and with event-driven architecture</li>\n<li>Sensible defaults: Underscore templates are used for view rendering</li>\n<li>Easily modifiable: make it work with your application’s specific needs</li>\n<li>Reduce boilerplate for views, with specialized view types</li>\n<li>Build on a modular architecture with an Application and modules that attach to it</li>\n<li>Compose your application’s visuals at runtime, with the Region and Layout objects</li>\n<li>Nested views and layouts within visual regions</li>\n<li>Built-in memory management and zombie-killing in views, regions and layouts</li>\n<li>Event-driven architecture with Backbone.Wreqr.EventAggregator</li>\n<li>Flexible, “as-needed” architecture allowing you to pick and choose what you need</li>\n<li>And much, much more</li>\n</ul>\n<p>In this example I will take the structure of libraries and dependencies explained in the blog entry <a target=\"_blank\" href=\"{{ site.url }}/articles/2014/06/01/what-is-and-how-it-works-requirejs/\">What is and how it works RequireJS</a> to create a MarionetteJS application.</p>\n<h1 id=\"1-router-module-\">1. Router Module.</h1>\n<p>MarionetteJS  implements the object <a target=\"_blank\" href=\"https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.approuter.md\">Marionette.AppRouter</a> that allows you to define the paths that respond to your application. Using <a target=\"_blank\" href=\"http://requirejs.org/\">RequireJS</a> we can create a module that defines an object for our routes, also allows us to create multiple  Route objects that can be instantiated for other applications by convenience.</p>\n<p>In our application we create a folder where modules live, named modules. See an example definition of a Route.</p>\n<pre><code>define([&quot;marionette&quot;], function (Marionette) {\n  var Router = Marionette.AppRouter.extend({\n    appRoutes: {\n      &quot;&quot;: &quot;home&quot;,\n    },\n    /* standard routes can be mixed with appRoutes/Controllers above */\n    routes : {\n      &quot;hello/:username&quot;: &quot;helloBuddy&quot;\n    },\n    helloBuddy : function (buddy) {\n      // Without controller the routing functions live in Router object\n      alert(&quot;Hello &quot; + buddy);\n    }\n  });\n\n  return Router;\n});\n</code></pre><p>As you can see the code has an anonymus definition that returns a Router object, which then will be required for our application.</p>\n<p>Then we must define the properties that are response functions of our application routes.</p>\n<p><em>AppRoutes</em>: Property that allows the definition of routes with convention: URL : Method Name, the method must be defined in the Controller module that is associated with the Route within the application. This option allows the response functions change dramatically, depending on the controller being involved in Route.</p>\n<p><em>routes</em>: Property that defines routes, but unlike the previous methods will be defined within the Router object. This option ensures that certain (s) routes have a specific desired behavior.</p>\n<p>Both properties can be used in the same definition without problem, but the routes should not be repeated.</p>\n<p>When the application starts the Router indicate which methods are executed in response to a route visited by a user.</p>\n<p>In the definition of Route we use the property routes with dynamic parameters. in the  route hello:username, username is a dynamic value passed as a parameter to the method of response to the route.</p>\n<h2 id=\"2-controller-module-\">2. Controller Module.</h2>\n<p>In the same way we did  for Routing will create a module for the controller, as shown below</p>\n<pre><code>define([&quot;marionette&quot;], function (Marionette) {\n\n    var Controller = Marionette.Controller.extend({\n        initialize : function(options) {\n             //TODO: code to initialize\n         },\n        start: function() {\n            //TODO: code to start\n        },\n\n        /**\n         * Initialized on start, without hash\n         * @method\n         */\n         home :  function () {\n            alert(&#39;Hello Marionette&#39;);\n        },\n    });\n\n    return Controller;\n});\n</code></pre><p>This module is anonymous and extend the <a target=\"_blank\" href=\"https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.controller.md\">Marionette.Controller</a> object as seen have initialize and start methods to perform tasks that are required at the time of the creation of the controller.</p>\n<p>Then you must define the properties that are response functions of our application routes. In our case we define the hello method.</p>\n<h2 id=\"3-invoking-controller-and-router\">3. Invoking Controller  and Router</h2>\n<p>When we declare our application we load the objects that define the Router and Controller, as shown below.</p>\n<pre><code>// Loading dependences and module to execute Marionette App\nrequire( [&quot;marionette&quot;,&quot;../modules/AppRouter&quot;, &quot;../modules/AppController&quot;], function (Marionette, AppRouter, AppController) {\n    // set up the app instance\n    var MyApp = new Marionette.Application();\n\n    // initialize the app controller\n    var controller = new AppController({});\n\n    // initialize the app router\n    MyApp.addInitializer(function(options) {\n        // initialize the router\n        var router = new AppRouter({\n          controller : controller\n        });\n    });\n\n    MyApp.on(&quot;initialize:after&quot;, function(){\n      // Start Backbone history a necessary step for bookmarkable URL&#39;s\n      Backbone.history.start();\n    });\n\n    MyApp.start({});\n});\n</code></pre><p>Although Route and Controller modules were anonymous, using RequireJS we can do load modules using the relative path of the modules as shown in detail in the next line.</p>\n<pre><code>require( [&quot;marionette&quot;,&quot;../modules/AppRouter&quot;, &quot;../modules/AppController&quot;], function (Marionette, AppRouter, AppController) {\n</code></pre><p>The returned objects are passed as a parameter to the anonymous function that defines the application.</p>\n<p>As seen proceeds to create an instance of the Controller object, which will be later used in the definition of the Router.</p>\n<pre><code>// initialize the app controller\nvar controller = new AppController({});\n</code></pre><p>In the initialization of our MarionetteJS application, we create the Router using the Controller.</p>\n<pre><code>// initialize the app router\nMyApp.addInitializer(function(options) {\n  // initialize the router\n  var router = new AppRouter({\n    controller : controller\n  });\n});\n</code></pre><p>Finally after finishing the initialization of our application should be activated BackboneJS history of what that will activate the process of routing.</p>\n<pre><code>MyApp.on(&quot;initialize:after&quot;, function(){\n  // Start Backbone history a necessary step for bookmarkable URL&#39;s\n  Backbone.history.start();\n});\n</code></pre><p>When it loads the application we will getan alert with the message “Hello Marionette” and if you change the URL to index.html#hello/ enzo you will get a resul similar to the following output.</p>\n<p><img src=\"http://7sabores.com/sites/default/files/styles/large/public/marionette_routing_sample.png?itok=2lla5O-u\"/></p>\n","updatedAt":"2017-09-05T17:40:56.000Z"}